<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.10: Schemas</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">版本号 5.0.10</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">版本号 4.13.11</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">版本号 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">快速开始 (Quick Start)</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">模式 (Schemas)</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">模式类型 (SchemaTypes)</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">连接 (Connections)</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">模型 (Models)</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">文档 (Documents)</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">子文档 (Subdocuments)</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">查询 (Queries)</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">验证 (Validation)</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">中间件 (Middleware)</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">填充 (Populate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">鉴别器 (Discriminators)</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">插件 (Plugins)</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">亚马逊网络服务 (AWS Lambda)</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">接口 (API)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">模式 (Schema)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">连接 (Connection)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">文档 (Document)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">模型 (Model)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">查询 (Query)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">聚合 (Aggregate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">模式类型 (SchemaType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">虚拟类型 (VirtualType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">错误 (Error)</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">版本兼容性</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">常见问题 (FAQ)</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h2>模式（Schemas）</h2><div class="important"><p>如果你还接触过Mongoose，请务必花几分钟阅读一下<a href="./index.html">快速开始</a>，可以让你对Mongoose如何工作有一个初步的概念。
如果你正在从<code>4.x</code>升级到<code>5.x</code>，请您花几分钟阅读一下<a href="https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md">迁移指南</a>.</p>
</div><h3 id="definition"><a href="#definition">定义你的schema</a></h3>

<p>在Mongoose中的所有东西都是开始于Schema的。每一个Schema对应于一个MongoDB的集合，
并且基于那个集合，定义了文档的格式。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
  <span class="hljs-keyword">var</span> Schema = mongoose.Schema;

  <span class="hljs-keyword">var</span> blogSchema = <span class="hljs-keyword">new</span> Schema({
    title:  <span class="hljs-built_in">String</span>,
    author: <span class="hljs-built_in">String</span>,
    body:   <span class="hljs-built_in">String</span>,
    comments: [{ body: <span class="hljs-built_in">String</span>, date: <span class="hljs-built_in">Date</span> }],
    date: { type: <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span>: <span class="hljs-built_in">Date</span>.now },
    hidden: <span class="hljs-built_in">Boolean</span>,
    meta: {
      votes: <span class="hljs-built_in">Number</span>,
      favs:  <span class="hljs-built_in">Number</span>
    }
  });
</code></pre>
<p>如果你想在后面添加额外的键值，请使用
<a href="./api.html#schema_Schema-add">Schema#add</a>方法。</p>
<p>代码中，<code>blogSchema</code>每一个<code>key</code>定义的文档属性，
会被映射成它相应的<a href="./api.html#schematype_SchemaType">SchemaType</a>。
例如，我们已经定义了一个<code>title</code>属性，它的SchemaType将会被映射为
<a href="./api.html#schema-string-js">String</a>，而对于<code>date</code>属性，
其SchemaType将会被映射为<code>Date</code>。键值也可以是嵌套对象，
包含更深一层的<code>key/type</code>对，就像上例中的<code>meta</code>属性。</p>
<p>允许的SchemaTypes有:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
</ul>
<p>了解更多，关于<a href="./schematypes.html">SchemaTypes</a>。</p>
<p>Schemas不仅定义了文档的结构和类型的映射，
还定义了文档的<a href="#methods">实例方法</a>，
<a href="#statics">静态Model方法</a>, <a href="#indexes">复合索引</a>,
以及叫做<a href="./middleware.html">中间件</a>的文档生命周期钩子。</p>
<h3 id="models"><a href="#models">创建一个model</a></h3>

<p>为了使用我们定义的Schema，我们需要将<code>blogSchema</code>转换为
我们可以使用的<a href="./models.html">Model</a>。
为了这么做，我们需要将它传递到<code>mongoose.model(modelName, schema)</code>中:</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Blog = mongoose.model(<span class="hljs-string">'Blog'</span>, blogSchema);
  <span class="hljs-comment">// 准备开始！</span>
</code></pre>
<h3 id="methods"><a href="#methods">实例方法</a></h3>

<p><code>Models</code>的实例就是<a href="./documents.html">documents</a>。
Documents拥有许多它们自己的<a href="./api.html#document-js">内建实例方法</a>。
我们也可以定义自己的文档实例方法。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// 定义一个schema</span>
  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, type: <span class="hljs-built_in">String</span> });

  <span class="hljs-comment">// 给animalSchema的"methods"对象分配一个函数</span>
  animalSchema.methods.findSimilarTypes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.model(<span class="hljs-string">'Animal'</span>).find({ type: <span class="hljs-keyword">this</span>.type }, cb);
  };
</code></pre>
<p>现在我们所有的<code>animal</code>实例，都拥有一个<code>findSimilarTypes</code>方法。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  <span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> Animal({ type: <span class="hljs-string">'dog'</span> });

  dog.findSimilarTypes(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, dogs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(dogs); <span class="hljs-comment">// woof</span>
  });
</code></pre>
<ul>
<li>覆盖默认的mongoose文档方法，可能会导致不可预料的后果。了解更多保留字，详见<a href="./api.html#schema_Schema.reserved">Schema.reserved</a>。</li>
<li><strong>不要</strong>使用箭头函数(<code>=&gt;</code>)，来定义方法。因为箭头函数<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this">未绑定<code>this</code></a>，所以你的方法<strong>没有</strong>途径获取文档，因此上例中的代码就不能正常工作。</li>
</ul>
<h3 id="statics"><a href="#statics">静态方法</a></h3>

<p>给<code>Model</code>添加一个静态方法也非常简单。
继续我们的<code>animalSchema</code>:</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// 给animalSchema的"statics"，分配一个函数属性</span>
  animalSchema.statics.findByName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) }, cb);
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.findByName(<span class="hljs-string">'fido'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<p>_ <strong>不要</strong>使用箭头函数(<code>=&gt;</code>)，来定义方法。因为箭头函数<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this">未绑定<code>this</code></a>，所以你的方法<strong>没有</strong>途径获取文档，因此上例中的代码就不能正常工作。_    </p>
<h3 id="query-helpers"><a href="#query-helpers">辅助查询函数</a></h3>

<p>你也可以添加辅助查询的函数，它就像实例方法一样，
但是只是用于mongoose的查询。辅助查询函数让你可以扩展mongoose的
<a href="./queries.html">链式查询生成器API</a>。</p>
<pre><code class="lang-javascript">  animalSchema.query.byName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) });
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.find().byName(<span class="hljs-string">'fido'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<h3 id="indexes"><a href="#indexes">索引</a></h3>

<p>MongoDB支持<a href="http://docs.mongodb.org/manual/indexes/">二级索引</a>。
通过mongoose，我们<a href="./api.html#schematype_SchemaType-index">在</a> <a href="./api.html#schematype_SchemaType-unique">这个</a> <a href="./api.html#schematype_SchemaType-sparse">路径</a> <a href="./api.html#schema_date_SchemaDate-expires">层</a>或<code>schema</code>层，通过<code>Schema</code>定义这些索引。
当生成<a href="https://docs.mongodb.com/manual/core/index-compound/">混合索引</a>时，
在schema层定义索引是非常必要的。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({
    name: <span class="hljs-built_in">String</span>,
    type: <span class="hljs-built_in">String</span>,
    tags: { type: [<span class="hljs-built_in">String</span>], index: <span class="hljs-literal">true</span> } <span class="hljs-comment">// field level</span>
  });

  animalSchema.index({ name: <span class="hljs-number">1</span>, type: <span class="hljs-number">-1</span> }); <span class="hljs-comment">// schema level</span>
</code></pre>
<p>当你的应用启动时，<code>Mongoose</code>为了在<code>Schema</code>中定义索引，将自动调用<a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code></a>。
<code>Mongoose</code>将会对每个索引，按照顺序调用<code>createIndex</code>，并且会在所有的<code>createIndex</code>调用成功或发生错误时，在<code>model</code>上触发<code>index</code>事件。
在开发中这样非常好，但是生成索引会导致<a href="http://docs.mongodb.org/manual/core/indexes/#index-creation-operations">显著的性能影响</a>，所以我们推荐在正式环境中关闭此功能。
通过在<code>Schema</code>中设置<code>autoIndex</code>为<code>false</code>来关闭自动生成索引，
或者在<code>connection</code>全局设置<code>autoIndex</code>为<code>false</code>。</p>
<pre><code class="lang-javascript">  mongoose.connect(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  animalSchema.set(<span class="hljs-string">'autoIndex'</span>, <span class="hljs-literal">false</span>);
  <span class="hljs-comment">// or</span>
  <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
</code></pre>
<p>Mongoose将会在索引生成完毕或发生错误时，触发<code>index</code>事件。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// Will cause an error because mongodb has an _id index by default that</span>
  <span class="hljs-comment">// is not sparse</span>
  animalSchema.index({ _id: <span class="hljs-number">1</span> }, { sparse: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);

  Animal.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// "_id index cannot be sparse"</span>
    <span class="hljs-built_in">console</span>.log(error.message);
  });
</code></pre>
<p>您也可以查看<a href="./api.html#model_Model.ensureIndexes">Model#ensureIndexes</a>方法。</p>
<h3 id="virtuals"><a href="#virtuals">虚拟类型(Virtuals)</a></h3>

<p><a href="./api.html#schema_Schema-virtual">虚拟类型（Virtuals）</a> 
是你可以获取和设置的文档，但是却不会向MongoDB存储。
<code>getters</code> 对于格式化和组合字段非常有用，
<code>setters</code> 对于分解一个值为多个值并存储时，很有用。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// define a schema</span>
  <span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
    name: {
      first: <span class="hljs-built_in">String</span>,
      last: <span class="hljs-built_in">String</span>
    }
  });

  <span class="hljs-comment">// compile our model</span>
  <span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, personSchema);

  <span class="hljs-comment">// create a document</span>
  <span class="hljs-keyword">var</span> axl = <span class="hljs-keyword">new</span> Person({
    name: { first: <span class="hljs-string">'Axl'</span>, last: <span class="hljs-string">'Rose'</span> }
  });
</code></pre>
<p>如果你想要打印<code>person</code>的全名，你也可以自己拼接：</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.name.first + <span class="hljs-string">' '</span> + axl.name.last); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>但是每次使用时如果都要拼接字段，会非常不灵活。
而且如果你想在名字上做一些额外的处理，
比如<a href="https://www.npmjs.com/package/diacritics">移除 diacritics</a>时，将会如何？
<a href="./api.html#virtualtype_VirtualType-get">虚拟属性 getter</a>让你可以
定义一个 <code>fullName</code> 属性，而不会存在于MongoDB中。</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last;
});
</code></pre>
<p>当你每次获取 <code>fullName</code>属性时，mongoose 将会调用你定义的 <code>getter</code> 函数：</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.fullName); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>如果你使用 <code>toJSON()</code> 或 <code>toObject()</code> （或者在mongoose文档上使用 <code>JSON.stringify()</code>），
mongoose 默认<em>不会</em>包含虚拟属性。
如果想获取虚拟属性，需要向
<a href="./api.html#document_Document-toObject">toObject()</a> 或 <code>toJSON()</code>中，
传入 <code>{ virtuals: true }</code> 的配置。</p>
<p>你也可以向虚拟属性中，添加自定义的 <code>setter</code>。
通过虚拟属性 <code>fullName</code>，你可以同时设置 <code>first name</code> 和 <code>last name</code> 的值。</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).
  get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last; }).
  set(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">this</span>.name.first = v.substr(<span class="hljs-number">0</span>, v.indexOf(<span class="hljs-string">' '</span>));
    <span class="hljs-keyword">this</span>.name.last = v.substr(v.indexOf(<span class="hljs-string">' '</span>) + <span class="hljs-number">1</span>);
  });

axl.fullName = <span class="hljs-string">'William Rose'</span>; <span class="hljs-comment">// 此时， `axl.name.first` 的值为 "William"</span>
</code></pre>
<p>在其他验证之前，虚拟属性的setter非常实用。
所以尽管上例中 <code>first</code> 和 <code>last</code> 字段都是必须的，但仍然可以运行。</p>
<p>虚拟属性不能做为queries和字段选择使用。
因为虚拟属性没有存在于MongoDB种，你不能用他们来进行查询。</p>
<h5 id="aliases"><a href="#aliases">别名（Aliases）</a></h5>

<p>别名是一个很特别的虚拟属性类型，
它的setter和getter将无缝地获取其他属性的get和set。
这样对于节省带宽是非常方便的，所以为了提高代码可读性，
你可以将数据库中的属性转换为一个简短的属性名。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
  n: {
    type: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// 访问`name`将返回`n`的值, </span>
    <span class="hljs-comment">// 设置 `n` 值同样也会设置 `name` 的值</span>
    alias: <span class="hljs-string">'name'</span>
  }
});

<span class="hljs-comment">// 设置 `name` 的值将会广播给 `n`</span>
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person({ name: <span class="hljs-string">'Val'</span> });
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.toObject({ virtuals: <span class="hljs-literal">true</span> })); <span class="hljs-comment">// { n: 'Val', name: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">// "Val"</span>

person.name = <span class="hljs-string">'Not Val'</span>;
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Not Val' }</span>
</code></pre>
<h3 id="options"><a href="#options">配置（Options）</a></h3>

<p><code>Schemas</code> 有少量可配置的属性，
可以通过传递给构造函数，或者直接 <code>set</code> 来进行配置：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, options);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..});
schema.set(option, value);
</code></pre>
<p>有效的配置选项:</p>
<ul>
<li><a href="#autoIndex">autoIndex</a></li>
<li><a href="#bufferCommands">bufferCommands</a></li>
<li><a href="#capped">capped</a></li>
<li><a href="#collection">collection</a></li>
<li><a href="#id">id</a></li>
<li><a href="#_id">_id</a></li>
<li><a href="#minimize">minimize</a></li>
<li><a href="#read">read</a></li>
<li><a href="#shardKey">shardKey</a></li>
<li><a href="#strict">strict</a></li>
<li><a href="#strictQuery">strictQuery</a></li>
<li><a href="#toJSON">toJSON</a></li>
<li><a href="#toObject">toObject</a></li>
<li><a href="#typeKey">typeKey</a></li>
<li><a href="#validateBeforeSave">validateBeforeSave</a></li>
<li><a href="#versionKey">versionKey</a></li>
<li><a href="#collation">collation</a></li>
<li><a href="#skipVersioning">skipVersioning</a></li>
<li><a href="#timestamps">timestamps</a></li>
</ul>
<h3 id="autoIndex"><a href="#autoIndex">选项: autoIndex</a></h3>

<p>在应用开始运行时，Mongoose会向你的<code>Schmea</code>中的每一个索引发送一个<a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code> 命令</a>
从Mongoose v3开始，索引是默认自动生成的。
如果你想禁用自动生成索引的功能，需要在索引生成的时候手动操作，
也就是把你的 <code>Schema</code> 的 <code>autoIndex</code> 选项设置为 <code>false</code>，
并在你的model上使用<a href="./api.html#model_Model.ensureIndexes">ensureIndexes</a>方法。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Clock = mongoose.model(<span class="hljs-string">'Clock'</span>, schema);
Clock.ensureIndexes(callback);
</code></pre>
<h3 id="bufferCommands"><a href="#bufferCommands">选项: bufferCommands</a></h3>

<p>默认情况下，从连接中断开始，直到重新连接，mongoose会缓存指令。
设置<code>bufferCommands</code> 为 <code>false</code> 可以禁用缓存。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<p>The schema <code>bufferCommands</code> option overrides the global <code>bufferCommands</code> option.</p>
<pre><code class="lang-javascript">mongoose.set(<span class="hljs-string">'bufferCommands'</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// 如果schema的选项是通过set设置的，下面的选项将会覆盖上面的</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<h3 id="capped"><a href="#capped">选项: capped</a></h3>

<p>Mongoose支持MongoDB的<a href="http://www.mongodb.org/display/DOCS/Capped+Collections">固定(capped)</a>集合。
确认设置基础的MongoDB集合为 <code>capped</code>，
<code>capped</code> 选项可以在<a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-size.">bytes</a>上
限制集合的最大占用空间。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: <span class="hljs-number">1024</span> });
</code></pre>
<p>如果你想传入一些类似于
<a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-max">max</a>
或 <a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-autoIndexId">autoIndexId</a>
这样的选项时，<code>capped</code> 也可以设置为一个对象。
这种情况下，<code>size</code> 选项是必填项。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: { size: <span class="hljs-number">1024</span>, max: <span class="hljs-number">1000</span>, autoIndexId: <span class="hljs-literal">true</span> } });
</code></pre>
<h3 id="collection"><a href="#collection">选项: collection</a></h3>

<p>默认情况下，Mongoose可以通过<a href="./api.html#utils_exports.toCollectionName">utils.toCollectionName</a>方法，
传入model的名字，来获取一个集合的名字。
这个方法会把名字变为复数。
对于你的集合，如果你想要一个不同的名字，可以设置此选项。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> dataSchema = <span class="hljs-keyword">new</span> Schema({..}, { collection: <span class="hljs-string">'data'</span> });
</code></pre>
<h3 id="id"><a href="#id">选项: id</a></h3>

<p>Mongoose默认会给你的每一个schema分配一个 <code>id</code> 虚拟属性，
其值为转化为string后的文档 <code>_id</code> 字段，也就是ObjectsId的十六进制字符串。
如果你不想在schema中添加 <code>id</code> 的getter，
你可以通过在schema构建的时候，传入参数禁用。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 默认行为</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// '50341373e894ad16347efe01'</span>

<span class="hljs-comment">// 禁用 id</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// undefined</span>
</code></pre>
<h3 id="_id"><a href="#_id">选项: _id</a></h3>

<p>如果one没有传入<a href="/docs/api.html#schema-js">Schema</a>构造函数，
Mongoose默认会给你的每一个schema分配一个 <code>_id</code> 字段。
为了和MongoDB的默认行为保持一致，
_id的类型会指定为<a href="/docs/api.html#schema_Schema.Types">ObjectId</a>。</p>
<p>你<strong>只能</strong>在子文档中使用这些选项。
Mongoose不能在没有id时，保存一个文档，
所以当你没有_id时保存文档，将会触发错误事件。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 默认行为</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p); <span class="hljs-comment">// { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }</span>

<span class="hljs-comment">// 禁用 _id</span>
<span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { _id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ children: [childSchema] });

<span class="hljs-keyword">var</span> Model = mongoose.model(<span class="hljs-string">'Model'</span>, parentSchema);

Model.create({ children: [{ name: <span class="hljs-string">'Luke'</span> }] }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// doc.children[0]._id 的值将为 undefined</span>
});
</code></pre>
<h3 id="minimize"><a href="#minimize">选项: minimize</a></h3>

<p>默认情况下，Mongoose将会通过删除空对象来 “最小化” schemas。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// `inventory`如果不是空对象，将进行存储</span>
<span class="hljs-keyword">var</span> frodo = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Frodo'</span>, inventory: { ringOfPower: <span class="hljs-number">1</span> }});
Character.findOne({ name: <span class="hljs-string">'Frodo'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Frodo', inventory: { ringOfPower: 1 }}</span>
});

<span class="hljs-comment">// `inventory`为空对象，将不会存储</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam' }</span>
});
</code></pre>
<p>这个行为可以通过设置 <code>minimize</code> 为 <code>false</code> 来覆盖。
设置后，将会保存空对象。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} }, { minimize: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// `inventory`为空时也会保存</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam', inventory: {}}</span>
});
</code></pre>
<h3 id="read"><a href="#read">选项: read</a></h3>

<p>允许在schema级设置<a href="/docs/api.html#query_Query-read">query#read</a>的值，
对所有从model衍生来的query提供了一种应用默认
<a href="http://docs.mongodb.org/manual/applications/replication/#replica-set-read-preference">ReadPreferences</a>的方式。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primary'</span> });            <span class="hljs-comment">// 别名 'p'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primaryPreferred'</span> });   <span class="hljs-comment">// 别名 'pp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondary'</span> });          <span class="hljs-comment">// 别名 's'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondaryPreferred'</span> }); <span class="hljs-comment">// 别名 'sp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'nearest'</span> });            <span class="hljs-comment">// 别名 'n'</span>
</code></pre>
<p>每一个由单词首字母组成的别名是可以使用的，从而避免拼错单词。</p>
<p><code>read</code> 选项允许我们指定 <em>tag sets</em>。这样可以告诉
<a href="https://github.com/mongodb/node-mongodb-native/">驱动（driver）</a>
从副本集的哪一个成员读取。
在<a href="http://docs.mongodb.org/manual/applications/replication/#tag-sets">这里</a>
和<a href="http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences">这里</a>
可以阅读更多关于标签集合（tag sets）的内容。</p>
<p><em>注意：在连接的时候，你也可以指定驱动优先读取
<a href="http://mongodb.github.com/node-mongodb-native/api-generated/replset.html?highlight=strategy">strategy</a>选项：</em></p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 周期性地ping副本集，来测量网络延时</span>
<span class="hljs-keyword">var</span> options = { replset: { strategy: <span class="hljs-string">'ping'</span> }};
mongoose.connect(uri, options);

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: [<span class="hljs-string">'nearest'</span>, { disk: <span class="hljs-string">'ssd'</span> }] });
mongoose.model(<span class="hljs-string">'JellyBean'</span>, schema);
</code></pre>
<h3 id="shardKey"><a href="#shardKey">选项: shardKey</a></h3>

<p><code>sharded</code>选项用于当我们有一个<a href="http://www.mongodb.org/display/DOCS/Sharding+Introduction">碎片化的 MongoDB 结构</a>时。
在所有的插入/更新操作时，每一个碎片化的集合会给出一个 <code>shard key</code>。
我们只需要把schema的shard设置为同一值既可。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({ .. }, { shardKey: { tag: <span class="hljs-number">1</span>, name: <span class="hljs-number">1</span> }})
</code></pre>
<p><em>注意 Mongoose 不会发送 <code>shardcollection</code> 指令给你。
你必须自己配置你的shard。</em></p>
<h3 id="strict">选项: strict</h3>

<p><code>strict</code>选项（默认打开）确保传入我们model构造函数中，
但没在schema中定义的值，不会保存到数据库中。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema 不会保存到数据库中</span>

<span class="hljs-comment">// 设置为 false</span>
<span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// 现在 iAmNotInTheSchema 可以保存到数据库</span>
</code></pre>
<p>同样会影响 <code>doc.set()</code> 设置的属性值。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.set(<span class="hljs-string">'iAmNotInTheSchema'</span>, <span class="hljs-literal">true</span>);
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema 没有保存到数据库</span>
</code></pre>
<p>通过传递第二个布尔值属性，在model实例层，值可能会被覆盖。
This value can be overridden at the model instance level by passing a second
boolean argument:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 打开 strict 模式</span>
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 关闭 strict 模式</span>
</code></pre>
<p><code>strict</code> 选项页可以设置为 <code>throw</code>。
此时如果设置了非法的值，将会报错。</p>
<p><em>注意：如果不设置schema选项，则任何设置在实例上，并且在schema上不存在的键值对总会被忽略。</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.iAmNotInTheSchema = <span class="hljs-literal">true</span>;
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema 永远不会存储到数据库中</span>
</code></pre>
<h3 id="strictQuery">选项: strictQuery</h3>

<p>为了向下兼容，对于<code>queries</code>，设置了<code>strict</code> 选项，将<strong>不能</strong>用于参数过滤。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, { strict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// Mongoose 将 **不会** 过滤出 `notInSchema: 1` 的文档, 尽管 `strict: true`</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<p><code>strict</code> 选项只用户数据更新。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 如果 `strict` 的值不是 `false`</span>
<span class="hljs-comment">// 则 Mongoose 将会从更新中剔除 `notInSchema` 的值</span>
MyModel.updateMany({}, { $set: { notInSchema: <span class="hljs-number">1</span> } });
</code></pre>
<p>Mongoose 有一个单独的 <code>strictQuery</code> 选项来切换严格模式是否可以进行过滤查询。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, {
  strict: <span class="hljs-literal">true</span>,
  strictQuery: <span class="hljs-literal">true</span> <span class="hljs-comment">// 打开严格模式下的过滤查询</span>
});
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// 因为 `strictQuery` 的值为 `true`</span>
<span class="hljs-comment">// 所以 Mongoose 将会剔除 `notInSchema: 1` 的值</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<h3 id="toJSON"><a href="#toJSON">选项: toJSON</a></h3>

<p>准确的说，和 <a href="#toObject">toObject</a> 选项一样，
但是只适用于文档的 <code>toJSON</code> 方法被调用的时候。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toJSON'</span>, { getters: <span class="hljs-literal">true</span>, virtuals: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m.toObject()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }</span>
<span class="hljs-built_in">console</span>.log(m.toJSON()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
<span class="hljs-comment">// 只要toJSON被调用，js对象无论何时都会被字符串化:</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(m)); <span class="hljs-comment">// { "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" }</span>
</code></pre>
<p>想要了解所有支持<code>toJSON/toObject</code>的选项，请查看 <a href="/docs/api.html#document_Document-toObject">这里</a>。</p>
<h3 id="toObject"><a href="#toObject">选项: toObject</a></h3>

<p>Documents have a <a href="/docs/api.html#document_Document-toObject">toObject</a> method
which converts the mongoose document into a plain javascript object. This
method accepts a few options. Instead of applying these options on a
per-document basis we may declare the options here and have it applied to
all of this schemas documents by default.</p>
<p>To have all virtuals show up in your <code>console.log</code> output, set the
<code>toObject</code> option to <code>{ getters: true }</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toObject'</span>, { getters: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
</code></pre>
<p>查看所有可用的 <code>toObject</code> 选项，请看<a href="/docs/api.html#document_Document-toObject">这里</a>。</p>
<h3 id="typeKey"><a href="#typeKey">选项: typeKey</a></h3>

<p>默认情况下，如果在schema中的对象如果有一个 <code>type</code> 的键，
则 mongoose 会将其做为类型声明来处理。
By default, if you have an object with key &#39;type&#39; in your schema, mongoose
will interpret it as a type declaration.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Mongoose 将会认为 'loc' 是一个 'String'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] } });
</code></pre>
<p>对于像 <a href="http://docs.mongodb.org/manual/reference/geojson/">geoJSON</a> 
这样的应用，<code>type</code> 属性将会非常重要。
你可以通过设置 &#39;typeKey&#39; 属性值，来找到 mongoose 正在使用的那个键的类型声明。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-comment">// Mongoose 将其解释为 'loc 是一个拥有两个键(type 和 coordinates)的对象'</span>
  loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] },
  <span class="hljs-comment">// Mongoose 将其解释为 'name 是一个 String'</span>
  name: { $type: <span class="hljs-built_in">String</span> }
}, { typeKey: <span class="hljs-string">'$type'</span> }); <span class="hljs-comment">// '$type' 是这个对象的类型声明的键</span>
</code></pre>
<h3 id="validateBeforeSave"><a href="#validateBeforeSave">选项: validateBeforeSave</a></h3>

<p>默认情况下，文档会在保存到数据库之前自动验证。
这将会防止不合法的的文档保存到数据库中。
如果你想要手动控制验证，并希望不用验证就可以保存数据，
你可以设置 <code>validateBeforeSave</code> 为 <code>false</code>。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.set(<span class="hljs-string">'validateBeforeSave'</span>, <span class="hljs-literal">false</span>);
schema.path(<span class="hljs-string">'name'</span>).validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> v != <span class="hljs-literal">null</span>;
});
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-literal">null</span> });
m.validate(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(err); <span class="hljs-comment">// 将会提示null是不允许的</span>
});
m.save(); <span class="hljs-comment">// 尽管值不合法，但是保存仍然是成功的</span>
</code></pre>
<h3 id="versionKey"><a href="#versionKey">选项: versionKey</a></h3>

<p>第一次通过Mongoose创建的文档，都会被设置一个 <code>versionKey</code> 属性。
这个属性值包含内部文档的<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">revision</a>。
<code>versionKey</code>选项是一个用于版本控制，正在使用路径的字符串，默认为 <code>__v</code>。
如果你的应用有冲突，你可以这样配置：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-string">'string'</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { __v: 0, name: 'mongoose v3' }</span>

<span class="hljs-comment">// 自定义 versionKey</span>
<span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-string">'_somethingElse'</span> })
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { _somethingElse: 0, name: 'mongoose v3' }</span>
</code></pre>
<p>文档版本控制也可以通过将 <code>versionKey</code> 设置为 <code>false</code> 来禁用。</p>
<p><em>不要禁用版本控制，除非你知道<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">你正在做什么</a>。</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'no versioning please'</span> });
thing.save(); <span class="hljs-comment">// { name: 'no versioning please' }</span>
</code></pre>
<h3 id="collation"><a href="#collation">选项: collation</a></h3>

<p>为每个查询（query）和聚合（aggregation）设置一个默认的
<a href="https://docs.mongodb.com/manual/reference/collation/">collation</a>
这里是一个对新手友好的 collation 概述。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>
}, { collation: { locale: <span class="hljs-string">'en_US'</span>, strength: <span class="hljs-number">1</span> } });

<span class="hljs-keyword">var</span> MyModel = db.model(<span class="hljs-string">'MyModel'</span>, schema);

MyModel.create([{ name: <span class="hljs-string">'val'</span> }, { name: <span class="hljs-string">'Val'</span> }]).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> MyModel.find({ name: <span class="hljs-string">'val'</span> });
  }).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) </span>{
    <span class="hljs-comment">// 两个文档，`docs` 都将包含, 因为 `strength: 1` 意味着</span>
    <span class="hljs-comment">// MongoDB 在匹配时将忽略大小写。</span>
  });
</code></pre>
<h3 id="skipVersioning"><a href="#skipVersioning">选项: skipVersioning</a></h3>

<p><code>skipVersioning</code>允许从版本控制中移除路径信息（也就是说，尽管路径发生变化，内部版本也不会增加）。
除非你知道你在做什么，否则请不要这么做。
对于子文档，请使用完整路径在父文档中添加。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { skipVersioning: { dontVersionMe: <span class="hljs-literal">true</span> } });
thing.dontVersionMe.push(<span class="hljs-string">'hey'</span>);
thing.save(); <span class="hljs-comment">// version 没有增加</span>
</code></pre>
<h3 id="timestamps"><a href="#timestamps">选项: timestamps</a></h3>

<p>如果设置了<code>timestamps</code>属性，Mongoose将会在你的schema中，
分配 <code>createdAt</code> 和 <code>updatedAt</code> 字段，
这两个值得类型为 <a href="./api.html#schema-date-js">Date</a>。</p>
<p>默认情况下，这两个字段的名称为 <code>createdAt</code> 和 <code>updatedAt</code>，
可以通过设置 <code>timestamps.createdAt</code> 和 <code>timestamps.updatedAt</code>的值，来自定义字段名。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { timestamps: { createdAt: <span class="hljs-string">'created_at'</span> } });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing();
thing.save(); <span class="hljs-comment">// `created_at` &amp; `updatedAt`将会被添加</span>
</code></pre>
<h3 id="useNestedStrict"><a href="#useNestedStrict">选项: useNestedStrict</a></h3>

<p>在Mongoose 4中，<code>update()</code> 和 <code>findOneAndUpdate()</code>
只会检查顶级schema的严格模式的配置。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema }, { strict: <span class="hljs-string">'throw'</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// 因为parentSchema有`strict: throw`属性</span>
  <span class="hljs-comment">// 而且`childSchema` 有 `strict: false` 属性，所以会报错。</span>
});

<span class="hljs-keyword">var</span> update = { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> };
<span class="hljs-keyword">var</span> opts = { strict: <span class="hljs-literal">false</span> };
Parent.update({}, update, opts, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// 因为传递了 `strict: false` 参数给 `update()`，</span>
  <span class="hljs-comment">// 覆盖了父 schema。</span>
});
</code></pre>
<p>如果你设置 <code>useNestedStrict</code> 为 <code>true</code>，
mongoose更新时，将会使用子schema的 <code>strict</code> 配置。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema },
  { strict: <span class="hljs-string">'throw'</span>, useNestedStrict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// 会运行</span>
});
</code></pre>
<h3 id="plugins"><a href="#plugins">插件化</a></h3>

<p>Schema可以<a href="./plugins.html">插件化</a>，
这样我们就能够把重复使用的部分打包成插件，
从而可以在社区或者项目之间共享。</p>
<h3 id="next">接下来</h3>

<p>现在我们已经对<code>Schemas</code>有一个大概的了解，
接下来的内容为<a href="/docs/schematypes.html">SchemaTypes</a>。</p>
</div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>