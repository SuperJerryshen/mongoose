<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.10: Middleware</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">版本号 5.0.10</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">版本号 4.13.11</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">版本号 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">快速开始 (Quick Start)</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">模式 (Schemas)</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">模式类型 (SchemaTypes)</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">连接 (Connections)</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">模型 (Models)</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">文档 (Documents)</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">子文档 (Subdocuments)</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">查询 (Queries)</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">验证 (Validation)</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">中间件 (Middleware)</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">填充 (Populate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">鉴别器 (Discriminators)</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">插件 (Plugins)</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">亚马逊网络服务 (AWS Lambda)</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">接口 (API)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">模式 (Schema)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">连接 (Connection)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">文档 (Document)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">模型 (Model)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">查询 (Query)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">聚合 (Aggregate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">模式类型 (SchemaType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">虚拟类型 (VirtualType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">错误 (Error)</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">版本兼容性</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">常见问题 (FAQ)</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h2 id="-middleware-">中间件(Middleware)</h2>
<p>中间件(也叫做预处理和后处理<em>钩子</em>)是传入控制异步函数执行的函数。
中间件指定于schema层，对于编写<a href="./plugins.html">插件</a>非常有用。
Mongoose 4.x版本拥有4种中间件：
document(文档)中间件、model(模型)中间件、aggregate(聚合)中间件和query(查询)中间件。
document中间件在下面的文档函数中是支持的。
在document中间件中，<code>this</code>指向此document。</p>
<ul>
<li><a href="./api.html#document_Document-init">init</a></li>
<li><a href="./api.html#document_Document-validate">validate</a></li>
<li><a href="./api.html#model_Model-save">save</a></li>
<li><a href="./api.html#model_Model-remove">remove</a></li>
</ul>
<p>query中间件支持下面的 Model 和 Query 函数。
<code>this</code>指向此query。</p>
<ul>
<li><a href="./api.html#query_Query-count">count</a></li>
<li><a href="./api.html#query_Query-find">find</a></li>
<li><a href="./api.html#query_Query-findOne">findOne</a></li>
<li><a href="./api.html#query_Query-findOneAndRemove">findOneAndRemove</a></li>
<li><a href="./api.html#query_Query-findOneAndUpdate">findOneAndUpdate</a></li>
<li><a href="./api.html#query_Query-update">update</a></li>
</ul>
<p>Aggregate 中间件用于 <code>MyModel.aggregate()</code>。
当你在aggregate对象上调用 <code>exec()</code> 时，Aggregate中间件将会执行。
在Aggregate中间件中， <code>this</code> 指向 <a href="./api.html#model_Model.aggregate">aggregation object</a>。</p>
<ul>
<li><a href="./api.html#model_Model.aggregate">聚合(aggregate)</a></li>
</ul>
<p>Model中间件支持下面的model函数，<code>this</code> 指向此model。</p>
<ul>
<li><a href="./api.html#model_Model.insertMany">insertMany</a></li>
</ul>
<p>所有的中间件类型支持预处理和后处理钩子。
下面将会详细介绍预处理和后处理钩子。</p>
<p><strong>注意：</strong> <code>remove()</code> 对于query没有钩子，只有document有。
如果你设置了一个&#39;remove&#39;钩子，它将会在你调用<code>myDoc.remove()</code>时触发，
而不是在调用<code>MyModel.remove()</code>时。
<strong>注意：</strong> <code>create()</code>函数会触发 <code>save()</code> 钩子。</p>
<h3 id="pre"><a href="#pre">预处理(Pre)</a></h3>

<p>有两种预处理钩子，分别是串行和并行。</p>
<h4 id="serial">串行(Serial)</h4>

<p>串行中间件函数在每一个中间件调用 <code>next</code> 后，会一个接着一个地执行。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// do stuff</span>
  next();
});
</code></pre>
<p>调用 <code>next()</code> <strong>不会</strong> 终止中间件中其他代码的执行。
在其他代码之前使用 <a href="https://www.bennadel.com/blog/2323-use-a-return-statement-when-invoking-callbacks-especially-in-a-guard-statement.htm"><code>return</code></a>
可以在调用 <code>next()</code> 时，阻止其他代码在中间件中执行。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (foo()) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'calling next!'</span>);
    <span class="hljs-comment">// `return next();` will make sure the rest of this function doesn't run</span>
    <span class="hljs-comment">/*return*/</span> next();
  }
  <span class="hljs-comment">// Unless you comment out the `return` above, 'after next' will print</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after next'</span>);
});
</code></pre>
<h4 id="parallel">并行(Parallel)</h4>

<p>并行中间件提供更细粒度的流控制。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);

<span class="hljs-comment">// `true` 以为着这是一个并行中间件。 </span>
<span class="hljs-comment">// 如果想要使用并行中间件，你**必须**指定 `true` 为第二个参数。</span>
schema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next, done</span>) </span>{
  <span class="hljs-comment">// calling next kicks off the next middleware in parallel</span>
  next();
  setTimeout(done, <span class="hljs-number">100</span>);
});
</code></pre>
<p>在 <code>save</code> 这种情况，钩子方法直到每一个中间件的 <code>done</code> 被调用后才会执行。</p>
<h4 id="use-cases">使用案例(Use Cases)</h4>

<p>中间件对于分离model逻辑非常有用。下面是一些其他建议：
Middleware are useful for atomizing model logic. Here are some other ideas:</p>
<ul>
<li>复合验证</li>
<li>删除依赖的document(删除用户的时候，删除他的所有博客)</li>
<li>默认异步</li>
<li>一个确定的任务触发一些异步任务</li>
</ul>
<h4 id="error-handling">错误处理(Error handling)</h4>

<p>如果任意中间件使用 <code>Error</code> 类的参数作为来调用 <code>next</code> 或 <code>done</code>，执行流将会被打断，
并且错误将会被传入回调函数中。</p>
<pre><code class="lang-javascript">schema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'something went wrong'</span>);
  next(err);
});

<span class="hljs-comment">// 然后...</span>

myDoc.save(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(err.message) <span class="hljs-comment">// 发生错误时</span>
});
</code></pre>
<h3 id="post"><a href="#post">Post中间件(Post middleware)</a></h3>

<p><a href="/docs/api.html#schema_Schema-post">post</a>中间件会在钩子方法<em>之后</em>执行，
并且所有中间件的 <code>pre</code> 都已经执行完毕。</p>
<pre><code class="lang-javascript">schema.post(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s has been initialized from the db'</span>, doc._id);
});
schema.post(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s has been validated (but not saved yet)'</span>, doc._id);
});
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s has been saved'</span>, doc._id);
});
schema.post(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s has been removed'</span>, doc._id);
});
</code></pre>
<h3 id="post-async"><a href="#post-async">异步post钩子(Asynchronous Post Hooks)</a></h3>

<p>如果你的post钩子函数接收至少两个参数，则mongoose将会假定第二个参数为一个 <code>next()</code> 函数，
你可以按顺序通过调用它，从而触发接下来的中间件。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 接收2个参数: 这是一个异步post钩子</span>
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, next</span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'post1'</span>);
    <span class="hljs-comment">// Kick off the second post hook</span>
    next();
  }, <span class="hljs-number">10</span>);
});

<span class="hljs-comment">// 直到第一个中间件调用 `next()` 后才会执行</span>
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, next</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'post2'</span>);
  next();
});
</code></pre>
<h3 id="order"><a href="#order">保存/验证钩子(Save/Validate Hooks)</a></h3>

<p><code>save()</code> 函数会触发 <code>validate()</code> 钩子，
因为mongoose有一个内建会调用 <code>validate()</code> 的 <code>pre(&#39;save&#39;)</code> 钩子。
这意味着所有的 <code>pre(&#39;validate&#39;)</code> 和 <code>post(&#39;validate&#39;)</code> 钩子，
会在所有的 <code>pre(&#39;save&#39;)</code> <strong>之前</strong>被调用。</p>
<pre><code class="lang-javascript">schema.pre(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this gets printed first'</span>);
});
schema.post(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this gets printed second'</span>);
});
schema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this gets printed third'</span>);
});
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this gets printed fourth'</span>);
});
</code></pre>
<h3 id="notes"><a href="#notes">使用findAndUpdate()和Query中间件的注意事项(Notes on findAndUpdate() and Query Middleware)</a></h3>

<p>在 <code>update()</code>、<code>findOneAndUpdate()</code> 等方法上，
<code>save()</code> 的预处理和后处理钩子将<strong>不会</strong>执行。
你可以在这个<a href="http://github.com/Automattic/mongoose/issues/964">github issue</a>中，
查看更深入的讨论。Mongoose 4.0 对这些函数采用了清晰的钩子。</p>
<pre><code class="lang-javascript">schema.pre(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> mongoose.Query); <span class="hljs-comment">// true</span>
  <span class="hljs-keyword">this</span>.start = <span class="hljs-built_in">Date</span>.now();
});

schema.post(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> mongoose.Query); <span class="hljs-comment">// true</span>
  <span class="hljs-comment">// prints returned documents</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'find() returned '</span> + <span class="hljs-built_in">JSON</span>.stringify(result));
  <span class="hljs-comment">// prints number of milliseconds the query took</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'find() took '</span> + (<span class="hljs-built_in">Date</span>.now() - <span class="hljs-keyword">this</span>.start) + <span class="hljs-string">' millis'</span>);
});
</code></pre>
<p>Query中间件相比于document中间件有一些微妙但很重要的不同点：
在document中间件中，更新文档时，<code>this</code> 指向该文档。
在Query中间件中，更新文档时，获取文档的引用不是必须的。
所以 <code>this</code> 指向 <strong>query</strong> 对象而不是被更新的文档对象。</p>
<p>对于实例，如果你想要在调用 <code>update()</code> 时添加一个
<code>updatedAt</code> 时间戳，你需要使用下面的预处理钩子。</p>
<pre><code class="lang-javascript">schema.pre(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.update({},{ $set: { updatedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() } });
});
</code></pre>
<h3 id="error-handling"><a href="#error-handling">错误处理中间件(Error Handling Middleware)</a></h3>

<p><em>v4.5.0 新增</em></p>
<p>正常情况下，如果中间件向 <code>next()</code> 传入一个错误 ，中间件的执行将会终止。
然而，有一种叫做 &quot;错误处理中间件&quot; 的特殊后处理中间件，在发生错误时，仍然可以继续执行。</p>
<p>错误处理中间件是一个可以接受一个额外参数的中间件：
&quot;错误&quot; 对象作为函数的第一个参数。
然后错误处理中间件可以将错误对象转换成你需要的形式。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  name: {
    type: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// 当你保存一个重复的文档时，</span>
    <span class="hljs-comment">// 将会触发一个错误码为 11000 的 MongoError</span>
    unique: <span class="hljs-literal">true</span>
  }
});

<span class="hljs-comment">// 处理函数**必须**接收3个参数：</span>
<span class="hljs-comment">// 发生的错误对象、发生问题的文档对象、`next()` 函数</span>
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc, next</span>) </span>{
  <span class="hljs-keyword">if</span> (error.name === <span class="hljs-string">'MongoError'</span> &amp;&amp; error.code === <span class="hljs-number">11000</span>) {
    next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'There was a duplicate key error'</span>));
  } <span class="hljs-keyword">else</span> {
    next(error);
  }
});

<span class="hljs-comment">// 将会触发 `post('save')` 的错误处理</span>
Person.create([{ name: <span class="hljs-string">'Axl Rose'</span> }, { name: <span class="hljs-string">'Axl Rose'</span> }]);
</code></pre>
<p>错误处理中间件在query中间件中也可以使用。
你同样可以定义一个后处理 <code>update()</code> 钩子，
从而可以捕获key重复时的错误。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 当调用 `update()` 时，将触发同样的E11000错误</span>
<span class="hljs-comment">// 此函数必**须接**收3个参数。This function **must** take 3 parameters. If you use the</span>
<span class="hljs-comment">// 如果使用了 `passRawResult` 函数，</span>
<span class="hljs-comment">// 函数就必须传入4个参数</span>
schema.post(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res, next</span>) </span>{
  <span class="hljs-keyword">if</span> (error.name === <span class="hljs-string">'MongoError'</span> &amp;&amp; error.code === <span class="hljs-number">11000</span>) {
    next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'There was a duplicate key error'</span>));
  } <span class="hljs-keyword">else</span> {
    next(error);
  }
});

<span class="hljs-keyword">var</span> people = [{ name: <span class="hljs-string">'Axl Rose'</span> }, { name: <span class="hljs-string">'Slash'</span> }];
Person.create(people, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  Person.update({ name: <span class="hljs-string">'Slash'</span> }, { $set: { name: <span class="hljs-string">'Axl Rose'</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// `error.message` will be "There was a duplicate key error"</span>
  });
});
</code></pre>
<h3 id="next">接下来</h3>

<p>我们已经介绍完中间件了，接下来让我们看一下
Mongoose通过它的query<a href="/docs/populate.html">填充</a>辅助函数修改连接的方法。</p>
</div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>