<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.10: Query Population</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">版本号 5.0.10</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">版本号 4.13.11</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">版本号 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">快速开始 (Quick Start)</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">模式 (Schemas)</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">模式类型 (SchemaTypes)</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">连接 (Connections)</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">模型 (Models)</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">文档 (Documents)</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">子文档 (Subdocuments)</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">查询 (Queries)</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">验证 (Validation)</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">中间件 (Middleware)</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">填充 (Populate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">鉴别器 (Discriminators)</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">插件 (Plugins)</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">亚马逊网络服务 (AWS Lambda)</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">接口 (API)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">模式 (Schema)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">连接 (Connection)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">文档 (Document)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">模型 (Model)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">查询 (Query)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">聚合 (Aggregate)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">模式类型 (SchemaType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">虚拟类型 (VirtualType)</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">错误 (Error)</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">版本兼容性</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">常见问题 (FAQ)</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h2 id="-populate-">填充(Populate)</h2>
<p>MongoDB在 &gt;= 3.2 的版本中，加入了类似链接的<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/">$lookup</a> 集成算子。
Mongoose有一个更强大替代方案叫做 <code>populate()</code>，它可以让你在其他集合中查询文档。</p>
<p>填充（Population）就是自动从其他collection的document，替换规定的路径下的document的过程。
我们可以填充单个的document，多个document，纯对象，多级纯对象，或者从查询返回的所有对象。
让我们看一下一些例子。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> Schema = mongoose.Schema;

<span class="hljs-keyword">var</span> personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: <span class="hljs-built_in">String</span>,
  age: <span class="hljs-built_in">Number</span>,
  stories: [{ type: Schema.Types.ObjectId, ref: <span class="hljs-string">'Story'</span> }]
});

<span class="hljs-keyword">var</span> storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: <span class="hljs-string">'Person'</span> },
  title: <span class="hljs-built_in">String</span>,
  fans: [{ type: Schema.Types.ObjectId, ref: <span class="hljs-string">'Person'</span> }]
});

<span class="hljs-keyword">var</span> Story = mongoose.model(<span class="hljs-string">'Story'</span>, storySchema);
<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, personSchema);
</code></pre>
<p>目前，我们已经创建了两个<a href="./models.html">Models</a>。
<code>Person</code> model的<code>stories</code>字段设置为一个<code>ObjectId</code>的数组。
<code>ref</code>选项告诉了Mongoose在填充时，会使用哪一个model。
在我们的例子中，就是<code>Story</code>model。
所有我们在这里存储的<code>_id</code>，必须是来自于<code>Story</code>model中文档的_id。</p>
<p><strong>注意</strong>: 虽然<code>ObjectId</code>, <code>Number</code>, <code>String</code>, and <code>Buffer</code>作为refs是合法的。
但是，你应该使用 <code>ObjectId</code>，除非你是一个高级用户，而且有足够的理由使用它。</p>
<h3 id="saving-refs"><a href="#saving-refs">保存 refs</a></h3>

<p>向其他文档保存refs，和其他保存值得方法一样，只是指定了 <code>_id</code> 的值：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> author = <span class="hljs-keyword">new</span> Person({
  _id: <span class="hljs-keyword">new</span> mongoose.Types.ObjectId(),
  name: <span class="hljs-string">'Ian Fleming'</span>,
  age: <span class="hljs-number">50</span>
});

author.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  <span class="hljs-keyword">var</span> story1 = <span class="hljs-keyword">new</span> Story({
    title: <span class="hljs-string">'Casino Royale'</span>,
    author: author._id    <span class="hljs-comment">// assign the _id from the person</span>
  });

  story1.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-comment">// thats it!</span>
  });
});
</code></pre>
<h3 id="population"><a href="#population">填充</a></h3>

<p>目前，我们还没有做太多不一样的事情。我们只不过创建了 <code>Person</code> 和 <code>Story</code>。
现在让我们看一下如何使用查询构建，来填充story的 <code>author</code> ：</p>
<pre><code class="lang-javascript">Story.
  findOne({ title: <span class="hljs-string">'Casino Royale'</span> }).
  populate(<span class="hljs-string">'author'</span>).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, story</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The author is %s'</span>, story.author.name);
    <span class="hljs-comment">// 打印 "The author is Ian Fleming"</span>
  });
</code></pre>
<p>通过在返回值之前，数据库会运行一个单独的查询，填充路径就不再是初始的 <code>_id</code>了，
他们的值将会被mongoose文档的返回值代替。</p>
<p>数组形式的refs也一样。
只是调用 <a href="./api.html#query_Query-populate">populate</a> 方法的返回值也会是数组形式，
每一个<code>_id</code>都会被单独的文档<em>代替</em>。</p>
<h3 id="setting-populated-fields"><a href="#setting-populated-fields">设置填充的字段</a></h3>

<p>在 &gt;= 4.0 的Mongoose版本中，你也可以手动填充一个字段。</p>
<pre><code class="lang-javascript">Story.findOne({ title: <span class="hljs-string">'Casino Royale'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, story</span>) </span>{
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">return</span> handleError(error);
  }
  story.author = author;
  <span class="hljs-built_in">console</span>.log(story.author.name); <span class="hljs-comment">// 打印 "Ian Fleming"</span>
});
</code></pre>
<h3 id="field-selection"><a href="#field-selection">字段选择</a></h3>

<p>如果我们只想返回一些特定的字段，该怎么办呢？
可以通过在调用<code>populate</code>方法时，
传入<a href="./api.html#query_Query-select">field name syntax</a>作为第二个参数就行了：</p>
<pre><code class="lang-javascript">Story.
  findOne({ title: <span class="hljs-regexp">/casino royale/i</span> }).
  populate(<span class="hljs-string">'author'</span>, <span class="hljs-string">'name'</span>). <span class="hljs-comment">// only return the Persons name</span>
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, story</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The author is %s'</span>, story.author.name);
    <span class="hljs-comment">// prints "The author is Ian Fleming"</span>

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The authors age is %s'</span>, story.author.age);
    <span class="hljs-comment">// prints "The authors age is null'</span>
  });
</code></pre>
<h3 id="populating-multiple-paths"><a href="#populating-multiple-paths">填充多路径（Populating Multiple Paths）</a></h3>

<p>如果我们想同时填充多个路径，该怎么办呢？</p>
<pre><code class="lang-javascript">Story.
  find(...).
  populate(<span class="hljs-string">'fans'</span>).
  populate(<span class="hljs-string">'author'</span>).
  exec();
</code></pre>
<p>我们在相同路径，调用 <code>populate()</code> 多次时，只有最后一个才会生效。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 第二次调用的`populate()`会覆盖第一次的</span>
<span class="hljs-comment">// 因为他们都是'fans'的填充</span>
Story.
  find().
  populate({ path: <span class="hljs-string">'fans'</span>, select: <span class="hljs-string">'name'</span> }).
  populate({ path: <span class="hljs-string">'fans'</span>, select: <span class="hljs-string">'email'</span> });
<span class="hljs-comment">// 等同于：</span>
Story.find().populate({ path: <span class="hljs-string">'fans'</span>, select: <span class="hljs-string">'email'</span> });
</code></pre>
<h3 id="query-conditions"><a href="#query-conditions">查询条件和其他设置</a></h3>

<p>如果我们根据年龄填充我们的<code>fans</code>，
只选择了他们的名字，最多返回五个时，会怎么样呢？</p>
<pre><code class="lang-javascript">Story.
  find(...).
  populate({
    path: <span class="hljs-string">'fans'</span>,
    match: { age: { $gte: <span class="hljs-number">21</span> }},
    <span class="hljs-comment">// 声明去掉 `_id`, 详见 http://bit.ly/2aEfTdB</span>
    select: <span class="hljs-string">'name -_id'</span>,
    options: { limit: <span class="hljs-number">5</span> }
  }).
  exec();
</code></pre>
<h3 id="refs-to-children"><a href="#refs-to-children">子 Refs</a></h3>

<p>如果使用 <code>author</code> 对象，我们可能无论如何都需要查找，但是却无法获取<code>stories</code>的列表。
这是因为 <code>story</code> 对象曾经被推到 <code>author.stories</code>过。
We may find however, if we use the <code>author</code> object, we are unable to get a
list of the stories. This is because no <code>story</code> objects were ever &#39;pushed&#39;
onto <code>author.stories</code>.</p>
<p>这里有两个观点。第一，你可能需要 <code>author</code> 知道哪些 <code>stories</code> 是他们自己的。
通常情况下，通过一个父节点，你的 <code>Schema</code> 应该是一对多关系中的多。
但是，如果你有必要去获得子节点的数组，你可以像下面这样，
通过 <code>push()</code> 向你的数组推document。
There are two perspectives here. First, you may want the <code>author</code> know
which stories are theirs. Usually, your schema should resolve
one-to-many relationships by having a parent pointer in the &#39;many&#39; side.
But, if you have a good reason to want an array of child pointers, you
can <code>push()</code> documents onto the array as shown below.</p>
<pre><code class="lang-javascript">author.stories.push(story1);
author.save(callback);
</code></pre>
<p>你可以链式运行 <code>find</code> 和 <code>populate</code>：</p>
<pre><code class="lang-javascript">Person.
  findOne({ name: <span class="hljs-string">'Ian Fleming'</span> }).
  populate(<span class="hljs-string">'stories'</span>). <span class="hljs-comment">// 只有设置了ref才会起作用</span>
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, person</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(person);
  });
</code></pre>
<p>如果设置了两个指针是有问题的，可能会导致其失去同步。
我们可以跳过填充，直接在运行 <code>find()</code> 找到我们需要的stories。</p>
<pre><code class="lang-javascript">Story.
  find({ author: author._id }).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stories</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The stories are an array: '</span>, stories);
  });
</code></pre>
<p>通过<a href="./api.html#query_Query-populate">query population</a>返回的文档是完全函数化的。
除非规定了<a href="./api.html#query_Query-lean">lean</a>值，
都可以通过<code>remove</code>或<code>save</code>删除和保存文档。
不要把这些和<a href="./subdocs.html">sub docs</a>搞混了。
当调用<code>remove</code>方法时要当心一点，因为你不仅会把他从数组删除，还会把他从数据库中删除。</p>
<h3 id="populate_an_existing_mongoose_document"><a href="#populate_an_existing_mongoose_document">填充已生成的文档</a></h3>

<p>如果我们想要填充一个已经生成过的mongoose文档，
在<strong>mongoose &gt;= 3.6</strong>时，支持
<a href="./api.html#document_Document-populate">document#populate()</a>方法。</p>
<h3 id="populate_multiple_documents"><a href="#populate_multiple_documents">填充多个已生成的文档</a></h3>

<p>如果我们有一个或多个文档，或者普通的对象
(_类似于 <a href="./api.html#model_Model.mapReduce">mapReduce</a> 的输出_)，
可以通过使用 <a href="./api.html#model_Model.populate">Model.populate()</a>
（<strong>mongoose &gt;= 3.6 可用</strong>） 填充他们。
这就是<code>document#populate()</code> 和 <code>query#populate()</code>填充文档的使用场景。</p>
<h3 id="deep-populate"><a href="#deep-populate">多级填充</a></h3>

<p>如果你有一个user的schema，它保存着user朋友的踪迹。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> userSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>,
  friends: [{ type: ObjectId, ref: <span class="hljs-string">'User'</span> }]
});
</code></pre>
<p>填充让你可以获取user好友的列表，
但是你还想获取user好友的好友时，该怎么办呢？
你可以通过配置 <code>populate</code>选项，
告诉mongoose去填充所有user朋友的 <code>friends</code> 数组：</p>
<pre><code class="lang-javascript">User.
  findOne({ name: <span class="hljs-string">'Val'</span> }).
  populate({
    path: <span class="hljs-string">'friends'</span>,
    <span class="hljs-comment">// 获取朋友的朋友的信息 - 对每一个friend填充 'friends' 信息</span>
    populate: { path: <span class="hljs-string">'friends'</span> }
  });
</code></pre>
<h3 id="cross-db-populate"><a href="#cross-db-populate">通过数据库填充</a></h3>

<p>现在有一个表示事件的schmea和一个表示会话的schema。
每一个事件有一个对应的会话索引。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>,
  <span class="hljs-comment">// 对应的会话 id</span>
  <span class="hljs-comment">// 注意：这里没有ref</span>
  conversation: ObjectId
});
<span class="hljs-keyword">var</span> conversationSchema = <span class="hljs-keyword">new</span> Schema({
  numMessages: <span class="hljs-built_in">Number</span>
});
</code></pre>
<p>假设事件和会话存储在分开的MongoDB实例中。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> db1 = mongoose.createConnection(<span class="hljs-string">'localhost:27000/db1'</span>);
<span class="hljs-keyword">var</span> db2 = mongoose.createConnection(<span class="hljs-string">'localhost:27001/db2'</span>);

<span class="hljs-keyword">var</span> Event = db1.model(<span class="hljs-string">'Event'</span>, eventSchema);
<span class="hljs-keyword">var</span> Conversation = db2.model(<span class="hljs-string">'Conversation'</span>, conversationSchema);
</code></pre>
<p>在这种情况下，你将<strong>不能</strong>正常使用 <code>populate()</code> 方法。
<code>conversation</code> 字段总会返回 <code>null</code>，
因为 <code>populate()</code> 不知道使用哪一个 model。
但是，<a href="./api.html#model_Model.populate">你可以明确指定 model</a>。</p>
<pre><code class="lang-javascript">Event.
  find().
  populate({ path: <span class="hljs-string">'conversation'</span>, model: Conversation }).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, docs</span>) </span>{ <span class="hljs-comment">/* ... */</span> });
</code></pre>
<p>这就是&quot;跨数据库填充&quot;，因为他让你可以通过
MongoDB数据库填充数据，甚至通过MongoDB实例。</p>
<h3 id="dynamic-ref"><a href="#dynamic-ref">动态References</a></h3>

<p>Mongoose 可以同时从不同的集合填充数据。
也就是说，拥有 &quot;connections&quot; 数组的user schema，
是可以连接到其他 user 或 organization。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> userSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>,
  connections: [{
    kind: <span class="hljs-built_in">String</span>,
    item: { type: ObjectId, refPath: <span class="hljs-string">'connections.kind'</span> }
  }]
});

<span class="hljs-keyword">var</span> organizationSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, kind: <span class="hljs-built_in">String</span> });

<span class="hljs-keyword">var</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);
<span class="hljs-keyword">var</span> Organization = mongoose.model(<span class="hljs-string">'Organization'</span>, organizationSchema);
</code></pre>
<p>上例中的<code>refPath</code>属性，意思是mongoose 会向上查找 <code>connections.kind</code> 路径，
来决定使用哪一个model来进行<code>populate()</code>都会被单独的文档<em>代替</em>。
也就是说，<code>refPath</code> 可以让 <code>ref</code> 属性成为动态的。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 我们有一个 organization:</span>
<span class="hljs-comment">// `{ _id: ObjectId('000000000000000000000001'), name: "Guns N' Roses", kind: 'Band' }`</span>
<span class="hljs-comment">// 和两个 users:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   _id: ObjectId('000000000000000000000002')</span>
<span class="hljs-comment">//   name: 'Axl Rose',</span>
<span class="hljs-comment">//   connections: [</span>
<span class="hljs-comment">//     { kind: 'User', item: ObjectId('000000000000000000000003') },</span>
<span class="hljs-comment">//     { kind: 'Organization', item: ObjectId('000000000000000000000001') }</span>
<span class="hljs-comment">//   ]</span>
<span class="hljs-comment">// },</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   _id: ObjectId('000000000000000000000003')</span>
<span class="hljs-comment">//   name: 'Slash',</span>
<span class="hljs-comment">//   connections: []</span>
<span class="hljs-comment">// }</span>
User.
  findOne({ name: <span class="hljs-string">'Axl Rose'</span> }).
  populate(<span class="hljs-string">'connections.item'</span>).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
    <span class="hljs-comment">// doc.connections[0].item is a User doc</span>
    <span class="hljs-comment">// doc.connections[1].item is an Organization doc</span>
  });
</code></pre>
<h3 id="populate-virtuals"><a href="#populate-virtuals">填充虚拟类型 (Populate Virtuals)</a></h3>

<p><em>4.5.0 版本新增</em></p>
<p>目前，你已经可以只通过 <code>_id</code> 填充数据。
然而，有时候就不是正确的选择了。尤其是当
<a href="https://docs.mongodb.com/manual/tutorial/model-referenced-one-to-many-relationships-between-documents/">数组是 MongoDB anti-pattern时，其增长是没有限制的</a>时。
使用mongoose 虚拟类型时，你可以在文档之间定义更加精细的关系。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> PersonSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>,
  band: <span class="hljs-built_in">String</span>
});

<span class="hljs-keyword">var</span> BandSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>
});
BandSchema.virtual(<span class="hljs-string">'members'</span>, {
  ref: <span class="hljs-string">'Person'</span>, <span class="hljs-comment">// 使用的 model</span>
  localField: <span class="hljs-string">'name'</span>, <span class="hljs-comment">// 从 `localField` 中查找</span>
  foreignField: <span class="hljs-string">'band'</span>, <span class="hljs-comment">// 等同于 `foreignField`</span>
  <span class="hljs-comment">// 如果 `justOne` 的值为 true, 'members' 将会是单个文档</span>
  <span class="hljs-comment">// false时，则为一个数组</span>
  <span class="hljs-comment">// `justOne` 默认值为 false</span>
  justOne: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, PersonSchema);
<span class="hljs-keyword">var</span> Band = mongoose.model(<span class="hljs-string">'Band'</span>, BandSchema);

<span class="hljs-comment">/**
 * 假设你有两个 bands："Guns N' Roses" 和 "Motley Crue"
 * 和四个 people: "Axl Rose" 、 带有"Guns N' Roses" 的 "Slash"
 * "Vince Neil" 和 带有"Motley Crue" 的 "Nikki Sixx"
 */</span>
Band.find({}).populate(<span class="hljs-string">'members'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, bands</span>) </span>{
  <span class="hljs-comment">/* `bands.members`为 `Person` 实例的一个数组 */</span>
});
</code></pre>
<p>注意，<code>toJSON()</code>的返回值默认<em>不包含</em>虚拟类型的值。
如果你想要填充虚拟属性时，又需要让类似于 Express 的 <a href="http://expressjs.com/en/4x/api.html#res.json"><code>res.json()</code> 函数</a>这样的
<code>JSON.stringify()</code>函数中含有这个虚拟属性，
可以通过在schema的<code>toJSON</code>选项中设置 <code>virtuals: true</code>。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 设置 `virtuals: true`，所以 `res.json()` 又起作用了</span>
<span class="hljs-keyword">var</span> BandSchema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>
}, { toJSON: { virtuals: <span class="hljs-literal">true</span> } });
</code></pre>
<p>如果你在使用填充投影（populate projections），
请确认<code>foreignField</code>包含在projection中。</p>
<pre><code class="lang-javascript">Band.
  find({}).
  populate({ path: <span class="hljs-string">'members'</span>, select: <span class="hljs-string">'name'</span> }).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, bands</span>) </span>{
    <span class="hljs-comment">// 不起作用, 在projection中， `band` 没有被选中</span>
  });

Band.
  find({}).
  populate({ path: <span class="hljs-string">'members'</span>, select: <span class="hljs-string">'name band'</span> }).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, bands</span>) </span>{
    <span class="hljs-comment">// 起作用, 外来的字段 `band` 是被选中的</span>
  });
</code></pre>
<h3 id="-">下一步</h3>
<p>既然你已经掌握了 <code>populate()</code>，
就让我们接着了解一下 <a href="/docs/discriminators.html">鉴别器 (discriminators)</a>。</p>
</div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>